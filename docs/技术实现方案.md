# 技术实现方案

文档版本：v1.1

最后更新日期：2024-08-06

## 目录

- [技术架构概述](#技术架构概述)
- [前端技术栈](#前端技术栈)
- [后端技术栈](#后端技术栈)
- [数据库设计](#数据库设计)
- [展会报名功能技术实现](#展会报名功能技术实现)
  - [参展人员信息管理](#参展人员信息管理)
  - [展商码与二维码生成](#展商码与二维码生成)
  - [身份验证机制](#身份验证机制)
  - [人流量统计系统](#人流量统计系统)
- [API接口设计](#api接口设计)
- [性能优化方案](#性能优化方案)
- [安全性考虑](#安全性考虑)
- [系统集成](#系统集成)
- [部署方案](#部署方案)

## 技术架构概述

人民城轨2.0系统采用前后端分离的架构设计，展会报名功能作为其中的重要模块，需要与现有系统进行无缝集成。整体架构如下：

- **前端**：Vue 3 + Element Plus + Vite
- **后端**：Spring Boot + Spring Cloud
- **数据库**：MySQL + Redis
- **文件存储**：MinIO/阿里云OSS
- **消息队列**：RabbitMQ（用于异步处理）
- **搜索引擎**：Elasticsearch（可选，用于大数据量查询）

## 前端技术栈

- **核心框架**：Vue 3
- **UI组件库**：Element Plus
- **构建工具**：Vite
- **状态管理**：Pinia
- **路由**：Vue Router
- **HTTP客户端**：Axios
- **二维码生成库**：QRCode.js
- **图表库**：ECharts
- **表格组件**：Element Plus Table
- **表单组件**：Element Plus Form
- **图标库**：FontAwesome

## 后端技术栈

- **核心框架**：Spring Boot 2.7.x
- **微服务框架**：Spring Cloud 2021.x
- **ORM框架**：MyBatis-Plus
- **缓存**：Redis
- **安全框架**：Spring Security + JWT
- **API文档**：Swagger/OpenAPI
- **二维码处理**：ZXing
- **文件处理**：Apache Commons FileUpload
- **异步处理**：Spring @Async + RabbitMQ
- **定时任务**：Spring Scheduler

## 数据库设计

### 数据结构关系图

```
exhibition_registration_entry (报名入口配置)
    |
    +-- exhibition_registration_info (报名信息)
            |
            +-- exhibition_attendee (参展人员)
            |       |
            |       +-- exhibition_attendee_material (参展人员材料)
            |       +-- exhibition_qr_code (展商码与二维码)
            |
            +-- exhibition_registration_material (报名材料)

identity_verification_record (身份验证记录)
    |
    +-- exhibition_attendee

footfall_statistics (人流量统计)
```

### 关键数据表结构

**1. exhibition_registration_entry (报名入口配置表)**
- id: BIGINT (主键)
- entry_name: VARCHAR(255) (入口名称)
- entry_type: VARCHAR(50) (入口类型)
- start_time: DATETIME (开始时间)
- end_time: DATETIME (结束时间)
- status: TINYINT (状态：0-禁用，1-启用)
- create_time: DATETIME (创建时间)
- update_time: DATETIME (更新时间)

**2. exhibition_registration_info (报名信息表)**
- id: BIGINT (主键)
- entry_id: BIGINT (关联报名入口ID)
- exhibitor_name: VARCHAR(255) (展商名称)
- contact_person: VARCHAR(100) (联系人)
- contact_phone: VARCHAR(20) (联系电话)
- email: VARCHAR(255) (电子邮箱)
- company_address: VARCHAR(500) (公司地址)
- business_license_no: VARCHAR(50) (营业执照编号)
- status: TINYINT (状态：0-待审核，1-审核通过，2-审核拒绝)
- audit_time: DATETIME (审核时间)
- audit_user_id: BIGINT (审核人ID)
- create_time: DATETIME (创建时间)
- update_time: DATETIME (更新时间)

**3. exhibition_attendee (参展人员表)**
- id: BIGINT (主键)
- registration_id: BIGINT (关联报名信息ID)
- name: VARCHAR(100) (姓名)
- gender: TINYINT (性别：0-男，1-女)
- id_type: VARCHAR(50) (证件类型)
- id_number: VARCHAR(100) (证件号码)
- phone: VARCHAR(20) (联系电话)
- email: VARCHAR(255) (电子邮箱)
- position: VARCHAR(100) (职位)
- create_time: DATETIME (创建时间)
- update_time: DATETIME (更新时间)

**4. exhibition_attendee_material (参展人员材料表)**
- id: BIGINT (主键)
- attendee_id: BIGINT (关联参展人员ID)
- material_type: VARCHAR(50) (材料类型)
- file_name: VARCHAR(255) (文件名)
- file_path: VARCHAR(500) (文件路径)
- file_size: BIGINT (文件大小)
- file_type: VARCHAR(50) (文件类型)
- upload_time: DATETIME (上传时间)

**5. exhibition_qr_code (展商码与二维码表)**
- id: BIGINT (主键)
- attendee_id: BIGINT (关联参展人员ID)
- qr_code_content: VARCHAR(500) (二维码内容)
- qr_code_image_path: VARCHAR(500) (二维码图片路径)
- unique_code: VARCHAR(100) (唯一码)
- status: TINYINT (状态：0-未使用，1-已使用，2-已过期)
- expire_time: DATETIME (过期时间)
- create_time: DATETIME (创建时间)

**6. identity_verification_record (身份验证记录表)**
- id: BIGINT (主键)
- attendee_id: BIGINT (关联参展人员ID)
- qr_code_id: BIGINT (关联二维码ID)
- verify_time: DATETIME (验证时间)
- verify_location: VARCHAR(255) (验证地点)
- verify_device_id: VARCHAR(100) (验证设备ID)
- verify_result: TINYINT (验证结果：0-失败，1-成功)
- failure_reason: VARCHAR(500) (失败原因)

**7. footfall_statistics (人流量统计表)**
- id: BIGINT (主键)
- statistics_time: DATETIME (统计时间)
- area_id: VARCHAR(100) (区域ID)
- area_name: VARCHAR(255) (区域名称)
- entry_count: INT (进入人数)
- exit_count: INT (离开人数)
- current_count: INT (当前人数)
- peak_count: INT (峰值人数)

## 展会报名功能技术实现

### 参展人员信息管理

#### 前端实现

- **页面组件**：
  - `ExhibitionAttendeeList.vue`：参展人员列表页面
  - `ExhibitionAttendeeForm.vue`：参展人员信息表单组件
  - `ExhibitionAttendeeDetail.vue`：参展人员详情组件

- **核心功能**：
  - 参展人员列表展示与分页
  - 参展人员信息添加、编辑、删除
  - 信息查询与筛选
  - 材料上传与预览

```javascript
// 参展人员列表数据获取示例代码
const fetchAttendeeList = async () => {
  try {
    loading.value = true;
    const response = await axios.get('/api/exhibition/attendees', {
      params: {
        page: currentPage.value,
        pageSize: pageSize.value,
        ...searchParams.value
      }
    });
    attendeeList.value = response.data.items;
    total.value = response.data.total;
  } catch (error) {
    ElMessage.error('获取参展人员列表失败');
    console.error('Fetch attendee list error:', error);
  } finally {
    loading.value = false;
  }
};

// 文件上传处理
const handleFileUpload = async (file) => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('attendeeId', currentAttendeeId.value);
  formData.append('materialType', currentMaterialType.value);
  
  try {
    const response = await axios.post('/api/exhibition/attendees/materials', formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    });
    ElMessage.success('文件上传成功');
    // 刷新材料列表
    fetchMaterialsList();
  } catch (error) {
    ElMessage.error('文件上传失败');
    console.error('File upload error:', error);
  }
};
```

#### 后端实现

- **Controller层**：
  - `ExhibitionAttendeeController`：处理参展人员相关API请求

- **Service层**：
  - `ExhibitionAttendeeService`：参展人员业务逻辑处理
  - `ExhibitionAttendeeMaterialService`：参展人员材料处理

- **数据访问层**：
  - `ExhibitionAttendeeMapper`：参展人员数据访问
  - `ExhibitionAttendeeMaterialMapper`：参展人员材料数据访问

```java
// 参展人员信息保存示例代码
@Service
public class ExhibitionAttendeeServiceImpl implements ExhibitionAttendeeService {
    
    @Autowired
    private ExhibitionAttendeeMapper attendeeMapper;
    
    @Autowired
    private ExhibitionAttendeeMaterialMapper materialMapper;
    
    @Override
    @Transactional
    public ExhibitionAttendee saveAttendee(ExhibitionAttendee attendee) {
        // 验证证件信息
        if (!validateIdNumber(attendee.getIdType(), attendee.getIdNumber())) {
            throw new BusinessException("证件信息验证失败");
        }
        
        // 保存参展人员信息
        if (attendee.getId() == null) {
            // 新增
            attendeeMapper.insert(attendee);
        } else {
            // 更新
            attendeeMapper.updateById(attendee);
        }
        
        return attendee;
    }
    
    @Override
    public void saveAttendeeMaterial(Long attendeeId, MultipartFile file, String materialType) {
        // 文件保存逻辑
        String filePath = fileStorageService.saveFile(file);
        
        // 保存材料记录
        ExhibitionAttendeeMaterial material = new ExhibitionAttendeeMaterial();
        material.setAttendeeId(attendeeId);
        material.setMaterialType(materialType);
        material.setFileName(file.getOriginalFilename());
        material.setFilePath(filePath);
        material.setFileSize(file.getSize());
        material.setFileType(file.getContentType());
        material.setUploadTime(new Date());
        
        materialMapper.insert(material);
    }
}
```

### 展商码与二维码生成

#### 技术选型

- **前端二维码生成**：QRCode.js
- **后端二维码生成**：ZXing (Zebra Crossing)
- **唯一性保障**：UUID + 时间戳 + 随机数

#### 前端实现

- **组件**：
  - `QRCodeGenerator.vue`：二维码生成组件
  - `QRCodePreview.vue`：二维码预览组件

- **核心功能**：
  - 单个二维码生成与预览
  - 批量二维码生成请求
  - 二维码样式自定义
  - 二维码下载与打印

```javascript
// 二维码生成示例代码
import QRCode from 'qrcodejs2';

const generateQRCode = (content, containerId) => {
  // 清空容器
  const container = document.getElementById(containerId);
  container.innerHTML = '';
  
  // 创建二维码
  new QRCode(container, {
    text: content,
    width: 300,
    height: 300,
    colorDark: "#000000",
    colorLight: "#ffffff",
    correctLevel: QRCode.CorrectLevel.M // 容错级别M
  });
};

// 批量生成二维码
const batchGenerateQRCodes = async (attendeeIds) => {
  try {
    loading.value = true;
    const response = await axios.post('/api/exhibition/qrcodes/batch', {
      attendeeIds: attendeeIds,
      options: {
        logoPath: logoPath.value,
        foregroundColor: foregroundColor.value
      }
    });
    
    // 获取任务ID，轮询任务状态
    const taskId = response.data.taskId;
    await pollTaskStatus(taskId);
    
    ElMessage.success('批量生成完成');
    // 刷新列表
    fetchAttendeeList();
  } catch (error) {
    ElMessage.error('批量生成失败');
    console.error('Batch generate error:', error);
  } finally {
    loading.value = false;
  }
};
```

#### 后端实现

- **Controller层**：
  - `QRCodeController`：处理二维码相关API请求

- **Service层**：
  - `QRCodeService`：二维码生成业务逻辑
  - `QRCodeAsyncService`：异步二维码生成服务

- **工具类**：
  - `QRCodeGeneratorUtil`：二维码生成工具类

```java
// 二维码生成服务示例代码
@Service
public class QRCodeServiceImpl implements QRCodeService {
    
    @Autowired
    private QRCodeGeneratorUtil qrCodeGeneratorUtil;
    
    @Autowired
    private ExhibitionQRCodeMapper qrCodeMapper;
    
    @Autowired
    private ExhibitionAttendeeMapper attendeeMapper;
    
    @Autowired
    private TaskService taskService;
    
    @Autowired
    private QRCodeAsyncService qrCodeAsyncService;
    
    @Override
    @Transactional
    public ExhibitionQRCode generateQRCode(Long attendeeId, QRCodeOptions options) {
        // 获取参展人员信息
        ExhibitionAttendee attendee = attendeeMapper.selectById(attendeeId);
        if (attendee == null) {
            throw new BusinessException("参展人员不存在");
        }
        
        // 生成唯一码
        String uniqueCode = generateUniqueCode();
        String qrContent = buildQRCodeContent(uniqueCode, attendeeId);
        
        // 生成二维码图片
        String imagePath = qrCodeGeneratorUtil.generateQRCode(qrContent, options);
        
        // 保存二维码记录
        ExhibitionQRCode qrCode = new ExhibitionQRCode();
        qrCode.setAttendeeId(attendeeId);
        qrCode.setQrCodeContent(qrContent);
        qrCode.setQrCodeImagePath(imagePath);
        qrCode.setUniqueCode(uniqueCode);
        qrCode.setStatus(0); // 0-未使用
        qrCode.setExpireTime(calculateExpireTime());
        qrCode.setCreateTime(new Date());
        
        qrCodeMapper.insert(qrCode);
        
        return qrCode;
    }
    
    @Override
    public String batchGenerateQRCodes(List<Long> attendeeIds, QRCodeOptions options) {
        // 创建异步任务
        String taskId = taskService.createTask("BATCH_QRCODE_GENERATE");
        
        // 异步处理批量生成
        qrCodeAsyncService.batchGenerateQRCodes(taskId, attendeeIds, options);
        
        return taskId;
    }
    
    private String generateUniqueCode() {
        return UUID.randomUUID().toString().replace("-", "") + 
               System.currentTimeMillis() + 
               RandomStringUtils.randomNumeric(6);
    }
    
    private String buildQRCodeContent(String uniqueCode, Long attendeeId) {
        // 构建二维码内容，仅包含唯一标识
        return "METRO_EXHIBITION:" + uniqueCode;
    }
    
    private Date calculateExpireTime() {
        // 计算过期时间，例如展会结束后7天
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DAY_OF_YEAR, 30);
        return calendar.getTime();
    }
}
```

### 身份验证机制

#### 技术选型

- **二维码扫描**：前端使用jsQR或QuaggaJS，移动端使用原生扫描SDK
- **身份验证**：JWT + Redis分布式缓存
- **离线验证**：SQLite本地数据库

#### 前端实现（验证设备）

- **组件**：
  - `QRCodeScanner.vue`：二维码扫描组件
  - `VerificationResult.vue`：验证结果展示组件
  - `OfflineDataManager.vue`：离线数据管理组件

- **核心功能**：
  - 实时二维码扫描
  - 在线/离线验证切换
  - 验证结果展示
  - 异常情况处理

```javascript
// 二维码扫描与验证示例代码
import jsQR from 'jsqr';

const startScan = () => {
  navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
    .then(stream => {
      video.value.srcObject = stream;
      video.value.setAttribute('playsinline', true); // iOS Safari支持
      video.value.play();
      requestAnimationFrame(tick);
    })
    .catch(err => {
      console.error('Camera error:', err);
      ElMessage.error('无法访问摄像头');
    });
};

const tick = () => {
  if (video.value.readyState === video.value.HAVE_ENOUGH_DATA) {
    canvas.value.height = video.value.videoHeight;
    canvas.value.width = video.value.videoWidth;
    const ctx = canvas.value.getContext('2d');
    ctx.drawImage(video.value, 0, 0, canvas.value.width, canvas.value.height);
    const imageData = ctx.getImageData(0, 0, canvas.value.width, canvas.value.height);
    
    // 识别二维码
    const code = jsQR(imageData.data, imageData.width, imageData.height);
    
    if (code && !scanned.value) {
      scanned.value = true;
      // 验证二维码
      verifyQRCode(code.data);
      // 3秒后重新开始扫描
      setTimeout(() => {
        scanned.value = false;
      }, 3000);
    }
  }
  requestAnimationFrame(tick);
};

const verifyQRCode = async (qrContent) => {
  try {
    // 首先尝试本地验证（离线模式）
    if (isOfflineMode.value) {
      const localResult = verifyOffline(qrContent);
      if (localResult) {
        showVerificationResult(localResult);
        // 记录离线验证日志，稍后同步
        recordOfflineVerification(localResult);
        return;
      }
    }
    
    // 在线验证
    const response = await axios.post('/api/exhibition/verification/verify', {
      qrCodeContent: qrContent,
      deviceId: deviceId.value,
      location: location.value
    });
    
    showVerificationResult(response.data);
    
    // 如果是离线模式下的在线验证成功，更新本地缓存
    if (isOfflineMode.value && response.data.verifyResult === 1) {
      updateOfflineCache(response.data);
    }
    
  } catch (error) {
    console.error('Verification error:', error);
    // 显示验证失败
    showVerificationResult({
      verifyResult: 0,
      failureReason: '网络错误，请检查网络连接'
    });
  }
};
```

#### 后端实现

- **Controller层**：
  - `VerificationController`：处理验证相关API请求

- **Service层**：
  - `VerificationService`：身份验证业务逻辑
  - `OfflineDataService`：离线数据管理服务

- **缓存管理**：
  - Redis缓存验证记录和黑名单

```java
// 身份验证服务示例代码
@Service
public class VerificationServiceImpl implements VerificationService {
    
    @Autowired
    private ExhibitionQRCodeMapper qrCodeMapper;
    
    @Autowired
    private ExhibitionAttendeeMapper attendeeMapper;
    
    @Autowired
    private IdentityVerificationRecordMapper verificationRecordMapper;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Override
    @Transactional
    public VerificationResult verifyQRCode(String qrContent, String deviceId, String location) {
        // 验证二维码格式
        if (!qrContent.startsWith("METRO_EXHIBITION:")) {
            return createFailureResult("无效的二维码");
        }
        
        String uniqueCode = qrContent.substring("METRO_EXHIBITION:".length());
        
        // 检查Redis缓存，快速验证黑名单
        if (redisTemplate.hasKey("qrcode:blacklist:" + uniqueCode)) {
            return createFailureResult("二维码已被列入黑名单");
        }
        
        // 查询二维码信息
        ExhibitionQRCode qrCode = qrCodeMapper.selectByUniqueCode(uniqueCode);
        if (qrCode == null) {
            return createFailureResult("二维码不存在");
        }
        
        // 检查状态和过期时间
        if (qrCode.getStatus() != 0) {
            return createFailureResult("二维码已使用");
        }
        
        if (new Date().after(qrCode.getExpireTime())) {
            // 更新为过期状态
            qrCode.setStatus(2);
            qrCodeMapper.updateById(qrCode);
            return createFailureResult("二维码已过期");
        }
        
        // 获取参展人员信息
        ExhibitionAttendee attendee = attendeeMapper.selectById(qrCode.getAttendeeId());
        if (attendee == null) {
            return createFailureResult("参展人员信息不存在");
        }
        
        // 更新二维码状态为已使用
        qrCode.setStatus(1);
        qrCodeMapper.updateById(qrCode);
        
        // 记录验证信息
        IdentityVerificationRecord record = new IdentityVerificationRecord();
        record.setAttendeeId(attendee.getId());
        record.setQrCodeId(qrCode.getId());
        record.setVerifyTime(new Date());
        record.setVerifyLocation(location);
        record.setVerifyDeviceId(deviceId);
        record.setVerifyResult(1); // 成功
        verificationRecordMapper.insert(record);
        
        // 缓存到Redis，提高后续查询效率
        redisTemplate.opsForValue().set(
            "qrcode:verified:" + uniqueCode,
            "1",
            7, TimeUnit.DAYS
        );
        
        // 更新人流量统计
        updateFootfallStatistics(location);
        
        // 返回成功结果
        VerificationResult result = new VerificationResult();
        result.setVerifyResult(1);
        result.setAttendeeInfo(convertToAttendeeInfo(attendee));
        result.setVerifyTime(new Date());
        
        return result;
    }
    
    private void updateFootfallStatistics(String location) {
        // 获取或创建当前时间段的统计记录
        FootfallStatistics statistics = getCurrentStatistics(location);
        
        // 更新进入人数
        statistics.setEntryCount(statistics.getEntryCount() + 1);
        statistics.setCurrentCount(statistics.getCurrentCount() + 1);
        
        // 更新峰值
        if (statistics.getCurrentCount() > statistics.getPeakCount()) {
            statistics.setPeakCount(statistics.getCurrentCount());
        }
        
        // 保存统计数据
        footfallStatisticsMapper.updateById(statistics);
    }
    
    // 其他辅助方法...
}
```

### 人流量统计系统

#### 技术选型

- **实时统计**：WebSocket + Redis计数器
- **数据存储**：MySQL（原始数据）+ Redis（实时统计）
- **数据可视化**：ECharts

#### 前端实现

- **组件**：
  - `FootfallDashboard.vue`：人流量统计仪表盘
  - `FootfallTrendChart.vue`：人流量趋势图
  - `AreaDistributionChart.vue`：区域分布图

- **核心功能**：
  - 实时数据展示
  - 历史数据查询
  - 多维度数据分析
  - 数据导出

```javascript
// 人流量统计数据获取示例代码
const fetchRealTimeData = () => {
  // 建立WebSocket连接
  if (!ws.value) {
    ws.value = new WebSocket('ws://' + window.location.host + '/ws/footfall');
    
    ws.value.onmessage = (event) => {
      const data = JSON.parse(event.data);
      realTimeData.value = data;
      updateCharts();
    };
    
    ws.value.onerror = (error) => {
      console.error('WebSocket error:', error);
      // 出错后切换到轮询模式
      startPolling();
    };
    
    ws.value.onclose = () => {
      console.log('WebSocket connection closed');
      // 连接关闭后切换到轮询模式
      startPolling();
    };
  }
};

const fetchHistoryData = async () => {
  try {
    loading.value = true;
    const response = await axios.get('/api/exhibition/footfall/history', {
      params: {
        startTime: startTime.value,
        endTime: endTime.value,
        areaId: selectedArea.value
      }
    });
    
    historyData.value = response.data;
    updateHistoryChart();
  } catch (error) {
    ElMessage.error('获取历史数据失败');
    console.error('Fetch history data error:', error);
  } finally {
    loading.value = false;
  }
};

const exportData = async () => {
  try {
    const response = await axios.get('/api/exhibition/footfall/export', {
      params: {
        startTime: startTime.value,
        endTime: endTime.value,
        format: exportFormat.value
      },
      responseType: 'blob'
    });
    
    // 处理文件下载
    const blob = new Blob([response.data], {
      type: exportFormat.value === 'excel' ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' : 'text/csv'
    });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `footfall_statistics_${formatDate(new Date())}.${exportFormat.value === 'excel' ? 'xlsx' : 'csv'}`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
    
    ElMessage.success('数据导出成功');
  } catch (error) {
    ElMessage.error('数据导出失败');
    console.error('Export data error:', error);
  }
};
```

#### 后端实现

- **Controller层**：
  - `FootfallController`：处理人流量统计相关API请求
  - `WebSocketHandler`：WebSocket连接处理

- **Service层**：
  - `FootfallService`：人流量统计业务逻辑
  - `DataExportService`：数据导出服务

- **缓存管理**：
  - Redis用于实时统计数据

```java
// 人流量统计服务示例代码
@Service
public class FootfallServiceImpl implements FootfallService {
    
    @Autowired
    private FootfallStatisticsMapper statisticsMapper;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private SimpMessagingTemplate messagingTemplate;
    
    @Override
    public void recordEntry(String areaId, String areaName) {
        // 记录进入
        recordFootfall(areaId, areaName, true);
    }
    
    @Override
    public void recordExit(String areaId, String areaName) {
        // 记录离开
        recordFootfall(areaId, areaName, false);
    }
    
    private void recordFootfall(String areaId, String areaName, boolean isEntry) {
        // 获取当前时间（精确到分钟）
        Date now = new Date();
        Date truncatedTime = truncateToMinute(now);
        
        // 获取或创建统计记录
        FootfallStatistics statistics = getOrCreateStatistics(truncatedTime, areaId, areaName);
        
        // 更新统计数据
        if (isEntry) {
            statistics.setEntryCount(statistics.getEntryCount() + 1);
            statistics.setCurrentCount(statistics.getCurrentCount() + 1);
        } else {
            statistics.setExitCount(statistics.getExitCount() + 1);
            statistics.setCurrentCount(Math.max(0, statistics.getCurrentCount() - 1));
        }
        
        // 更新峰值
        if (statistics.getCurrentCount() > statistics.getPeakCount()) {
            statistics.setPeakCount(statistics.getCurrentCount());
        }
        
        // 保存到数据库
        statisticsMapper.updateById(statistics);
        
        // 更新Redis缓存（实时统计）
        String redisKey = "footfall:realtime:" + areaId;
        redisTemplate.opsForValue().set(redisKey, String.valueOf(statistics.getCurrentCount()));
        
        // 发布WebSocket消息
        publishFootfallUpdate(areaId, statistics.getCurrentCount(), isEntry);
    }
    
    @Override
    public Map<String, Object> getRealTimeStatistics() {
        // 从Redis获取所有区域的实时人数
        Map<String, Object> result = new HashMap<>();
        
        // 获取所有区域键
        Set<String> keys = redisTemplate.keys("footfall:realtime:*");
        if (keys != null) {
            for (String key : keys) {
                String areaId = key.substring("footfall:realtime:".length());
                String count = redisTemplate.opsForValue().get(key);
                result.put(areaId, Integer.parseInt(count != null ? count : "0"));
            }
        }
        
        // 计算总数
        int totalCount = result.values().stream()
                .mapToInt(value -> Integer.parseInt(value.toString()))
                .sum();
        result.put("total", totalCount);
        
        return result;
    }
    
    private void publishFootfallUpdate(String areaId, int currentCount, boolean isEntry) {
        FootfallUpdate update = new FootfallUpdate();
        update.setAreaId(areaId);
        update.setCurrentCount(currentCount);
        update.setIsEntry(isEntry);
        update.setTimestamp(new Date());
        
        // 发布到WebSocket主题
        messagingTemplate.convertAndSend("/topic/footfall", update);
    }
    
    // 其他辅助方法...
}
```

## API接口设计

### 参展人员管理接口

| API路径 | 方法 | 功能描述 | 参数 | 成功响应 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/exhibition/attendees` | GET | 获取参展人员列表 | page, pageSize, searchParams | `{"items": [...], "total": 100}` |
| `/api/exhibition/attendees` | POST | 新增参展人员 | attendee对象 | 新增的attendee对象 |
| `/api/exhibition/attendees/{id}` | GET | 获取参展人员详情 | id | attendee对象 |
| `/api/exhibition/attendees/{id}` | PUT | 更新参展人员信息 | id, attendee对象 | 更新后的attendee对象 |
| `/api/exhibition/attendees/{id}` | DELETE | 删除参展人员 | id | `{"success": true}` |
| `/api/exhibition/attendees/{id}/materials` | GET | 获取参展人员材料列表 | id | 材料列表 |
| `/api/exhibition/attendees/materials` | POST | 上传参展人员材料 | file, attendeeId, materialType | 上传结果 |

### 二维码管理接口

| API路径 | 方法 | 功能描述 | 参数 | 成功响应 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/exhibition/qrcodes/{attendeeId}` | POST | 生成单个二维码 | attendeeId, options | 二维码对象 |
| `/api/exhibition/qrcodes/batch` | POST | 批量生成二维码 | attendeeIds, options | `{"taskId": "..."}` |
| `/api/exhibition/qrcodes/task/{taskId}` | GET | 查询批量生成任务状态 | taskId | 任务状态对象 |
| `/api/exhibition/qrcodes/{id}` | GET | 获取二维码详情 | id | 二维码对象 |
| `/api/exhibition/qrcodes/{id}/download` | GET | 下载二维码图片 | id | 图片文件流 |
| `/api/exhibition/qrcodes/batch/download` | POST | 批量下载二维码 | ids | 压缩文件流 |

### 身份验证接口

| API路径 | 方法 | 功能描述 | 参数 | 成功响应 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/exhibition/verification/verify` | POST | 验证二维码 | qrCodeContent, deviceId, location | 验证结果对象 |
| `/api/exhibition/verification/records` | GET | 获取验证记录 | page, pageSize, searchParams | `{"items": [...], "total": 100}` |
| `/api/exhibition/verification/offline-data` | GET | 获取离线验证数据 | lastSyncTime | 离线数据包 |
| `/api/exhibition/verification/sync-records` | POST | 同步离线验证记录 | records | 同步结果 |

### 人流量统计接口

| API路径 | 方法 | 功能描述 | 参数 | 成功响应 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/exhibition/footfall/realtime` | GET | 获取实时人流量 | 无 | 实时统计数据 |
| `/api/exhibition/footfall/history` | GET | 获取历史人流量数据 | startTime, endTime, areaId | 历史数据列表 |
| `/api/exhibition/footfall/export` | GET | 导出人流量数据 | startTime, endTime, format | 文件流 |
| `/api/exhibition/footfall/area-distribution` | GET | 获取区域分布数据 | timeRange | 区域分布数据 |

## 性能优化方案

### 前端优化

1. **懒加载**：
   - 路由组件懒加载
   - 图片懒加载
   - 组件按需加载

2. **缓存策略**：
   - 本地存储常用数据
   - ETag实现HTTP缓存
   - Web Storage缓存用户偏好设置

3. **渲染优化**：
   - 虚拟列表处理大数据量表格
   - 防抖节流优化用户输入和交互
   - 使用CSS动画替代JavaScript动画

4. **资源优化**：
   - 代码分割
   - 资源压缩
   - CDN加速

### 后端优化

1. **数据库优化**：
   - 合理设计索引
   - 读写分离
   - 分库分表（针对大数据量）

2. **缓存优化**：
   - Redis缓存热点数据
   - 多级缓存策略
   - 缓存预热和更新机制

3. **异步处理**：
   - 消息队列处理异步任务
   - 异步批量操作
   - 异步日志记录

4. **并发优化**：
   - 连接池优化
   - 线程池调优
   - 分布式锁处理并发问题

### 二维码生成优化

1. **批量生成优化**：
   - 使用线程池并行生成
   - 分页处理大批量请求
   - 断点续传和任务恢复

2. **存储优化**：
   - 压缩二维码图片
   - 使用CDN分发图片资源
   - 定期清理过期二维码

## 安全性考虑

### 数据安全

1. **数据加密**：
   - 传输加密（HTTPS/TLS）
   - 存储加密（敏感数据加密存储）
   - 字段级加密（证件号码等隐私信息）

2. **访问控制**：
   - 基于角色的访问控制（RBAC）
   - 细粒度权限控制
   - API访问频率限制

3. **数据保护**：
   - 数据脱敏
   - 数据备份与恢复
   - 防止SQL注入和XSS攻击

### 二维码安全

1. **唯一性保障**：
   - 多重算法确保唯一性
   - 数据库唯一索引约束
   - 生成记录审计

2. **防伪措施**：
   - 二维码时效性控制
   - 防伪水印
   - 动态二维码（可选）

3. **验证安全**：
   - 防重放攻击
   - 异常验证监控
   - 黑名单机制

### 等保三级要求

1. **安全管理**：
   - 安全管理制度
   - 安全培训
   - 安全事件响应

2. **技术防护**：
   - 入侵检测
   - 病毒防护
   - 日志审计

3. **合规性**：
   - 定期安全评估
   - 漏洞扫描
   - 渗透测试

## 系统集成

### 与现有系统集成

1. **导航菜单集成**：
   - 在现有系统导航中添加展会报名相关菜单项
   - 权限控制集成

2. **用户认证集成**：
   - 复用现有认证体系
   - 单点登录（SSO）集成

3. **数据共享**：
   - 与用户管理系统共享用户信息
   - 与内容管理系统共享展会信息

### 第三方系统集成

1. **短信服务**：
   - 集成短信发送API
   - 短信验证码和通知

2. **文件存储**：
   - 集成对象存储服务
   - 文件上传下载管理

3. **支付系统**：
   - 可选集成支付功能
   - 订单管理

## 部署方案

### 环境要求

- **开发环境**：
  - JDK 1.8+
  - Node.js 14+
  - MySQL 8.0+
  - Redis 6.0+

- **生产环境**：
  - JDK 1.8+
  - MySQL 8.0+（主从架构）
  - Redis 6.0+（集群）
  - Nginx
  - Docker + Kubernetes（推荐）

### 部署步骤

1. **准备工作**：
   - 环境配置
   - 数据库初始化
   - 缓存服务启动

2. **后端部署**：
   - 打包应用（Maven）
   - 部署到应用服务器
   - 配置负载均衡

3. **前端部署**：
   - 构建应用（npm run build）
   - 部署到Web服务器
   - 配置CDN

4. **监控与维护**：
   - 应用监控
   - 日志收集
   - 性能监控

## 版本历史

| 版本号 | 更新日期 | 更新内容 | 更新人 |
| :--- | :--- | :--- | :--- |
| v1.1 | 2024-08-06 | 添加展会报名功能技术实现，特别是二维码生成、身份验证和人流量统计相关技术细节 | 技术团队 |
| v1.0 | 2024-07-30 | 初始版本，包含基本技术架构和组件规划 | 技术团队 |